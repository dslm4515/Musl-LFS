#!/bin/sh -e

# This script is run if an optical drive lacks a rule for persistent naming.
#
# It adds symlinks for optical drives based on the device class determined
# by cdrom_id and used ID_PATH to identify the device.

# (C) 2006 Marco d'Itri <md@Linux.IT>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# debug, if UDEV_LOG=<debug>
if [ -n "$UDEV_LOG" ]; then
        if [ "$UDEV_LOG" -ge 7 ]; then
                set -x
        fi
fi

RULES_FILE="/etc/udev/rules.d/70-persistent-cd.rules"

. /lib/udev/rule_generator.functions

find_next_available() {
        raw_find_next_available "$(find_all_rules 'SYMLINK\+=' "$1")"
}

write_rule() {
        local match="$1"
        local link="$2"
        local comment="$3"

        {
        if [ "$PRINT_HEADER" ]; then
                PRINT_HEADER=
                echo "# This file was automatically generated by the $0"
                echo "# program, run by the cd-aliases-generator.rules rules file."
                echo "#"
                echo "# You can modify it, as long as you keep each rule on a single"
                echo "# line, and set the \$GENERATED variable."
                echo ""
        fi

        [ "$comment" ] && echo "# $comment"
        echo "$match, SYMLINK+=\"$link\", ENV{GENERATED}=\"1\""
        } >> $RULES_FILE
        SYMLINKS="$SYMLINKS $link"
}

if [ -z "$DEVPATH" ]; then
        echo "Missing \$DEVPATH." >&2
        exit 1
fi
if [ -z "$ID_CDROM" ]; then
        echo "$DEVPATH is not a CD reader." >&2
        exit 1
fi

if [ "$1" ]; then
        METHOD="$1"
else
        METHOD='by-path'
fi

case "$METHOD" in
        by-path)
        if [ -z "$ID_PATH" ]; then
                echo "$DEVPATH not supported by path_id. by-id may work." >&2
                exit 1
        fi
        RULE="ENV{ID_PATH}==\"$ID_PATH\""
        ;;

        by-id)
        if [ "$ID_SERIAL" ]; then
                RULE="ENV{ID_SERIAL}==\"$ID_SERIAL\""
        elif [ "$ID_MODEL" -a "$ID_REVISION" ]; then
                RULE="ENV{ID_MODEL}==\"$ID_MODEL\", ENV{ID_REVISION}==\"$ID_REVISION\""
        else
                echo "$DEVPATH not supported by ata_id. by-path may work." >&2
                exit 1
        fi
        ;;

        *)
        echo "Invalid argument (must be either by-path or by-id)." >&2
        exit 1
        ;;
esac

# Prevent concurrent processes from modifying the file at the same time.
lock_rules_file

# Check if the rules file is writeable.
choose_rules_file

link_num=$(find_next_available 'cdrom[0-9]*')

match="SUBSYSTEM==\"block\", ENV{ID_CDROM}==\"?*\", $RULE"

comment="$ID_MODEL ($ID_PATH)"

        write_rule "$match" "cdrom$link_num" "$comment"
[ "$ID_CDROM_CD_R" -o "$ID_CDROM_CD_RW" ] && \
        write_rule "$match" "cdrw$link_num"
[ "$ID_CDROM_DVD" ] && \
        write_rule "$match" "dvd$link_num"
[ "$ID_CDROM_DVD_R" -o "$ID_CDROM_DVD_RW" -o "$ID_CDROM_DVD_RAM" ] && \
        write_rule "$match" "dvdrw$link_num"
echo >> $RULES_FILE

unlock_rules_file

echo $SYMLINKS

exit 0
